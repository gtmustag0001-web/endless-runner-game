<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ninja Platformer</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{
  background:#000;
  overflow:hidden;
  font-family:Arial,Helvetica,sans-serif;
}
#gameCanvas{
  display:block;
  background:linear-gradient(to bottom,#87CEEB 0%,#98D8E8 50%,#E0F6FF 100%);
}
#ui{
  position:fixed;top:10px;left:10px;
  color:#fff;font-weight:bold;
  text-shadow:2px 2px 4px rgba(0,0,0,0.7);
  z-index:10;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">Score: <span id="score">0</span> | Lives: <span id="lives">3</span></div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// ====== LEVEL ======
const TILE_SIZE = 48;
const level = [
  "000000000000000000000000000000000000000000",
  "000000000000000000000000000000000000000000",
  "000000000000000000000000000000000000000000",
  "000000000000000000000000000000000000000000",
  "000000000000003000000000000000000000000000",
  "000000000000001111000000000000000000000000",
  "000000000000000000000000003000000000000000",
  "000000000000000000000000001111000000000000",
  "000000000003000000000000000000000000000000",
  "000000000001111000000000000000000000000000",
  "000000000000000000000000000000000000000000",
  "111111111111111111111111111111111111111111",
];

const rows = level.length;
const cols = level[0].length;
const tiles = [];
for(let r=0;r<rows;r++){
  tiles[r]=[];
  for(let c=0;c<cols;c++){
    tiles[r][c]=parseInt(level[r][c],10);
  }
}

// ====== PLAYER & CAMERA ======
const player = {
  x: TILE_SIZE*2,
  y: TILE_SIZE*8,
  w: 32,
  h: 48,
  vx: 0,
  vy: 0,
  speed: 260,
  jumpForce: 820,   // high jump
  onGround: false
};

let cameraX = 0;
let score = 0;
let lives = 3;

// enemies array (abhi empty)
const enemies = [];

// ====== INPUT ======
let keyLeft=false,keyRight=false,keyJump=false;

window.addEventListener("keydown",e=>{
  if(["ArrowLeft","ArrowRight","ArrowUp","Space"," "].includes(e.code)) e.preventDefault();
  if(e.code==="ArrowLeft")  keyLeft=true;
  if(e.code==="ArrowRight") keyRight=true;
  if(e.code==="ArrowUp"||e.code==="Space") keyJump=true;
});
window.addEventListener("keyup",e=>{
  if(e.code==="ArrowLeft")  keyLeft=false;
  if(e.code==="ArrowRight") keyRight=false;
  if(e.code==="ArrowUp"||e.code==="Space") keyJump=false;
});

canvas.addEventListener("touchstart",e=>{
  e.preventDefault();
  keyJump = true;
});

// ====== PHYSICS ======
const GRAVITY = 2000;
const MAX_FALL_SPEED = 1200;

function rectIntersect(a,b){
  return a.x < b.x + b.w &&
         a.x + a.w > b.x &&
         a.y < b.y + b.h &&
         a.y + a.h > b.y;
}

function getTileAt(x,y){
  if(x<0 || y<0) return 0;
  const c = Math.floor(x / TILE_SIZE);
  const r = Math.floor(y / TILE_SIZE);
  if(r<0 || r>=rows || c<0 || c>=cols) return 0;
  return tiles[r][c];
}

// ====== GAME LOOP ======
let lastTime = performance.now();
function loop(now=performance.now()){
  const dt = (now-lastTime)/1000;
  lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// ====== UPDATE ======
function update(dt){
  player.vx = 0;
  if(keyLeft)  player.vx -= player.speed;
  if(keyRight) player.vx += player.speed;

  if(keyJump && player.onGround){
    player.vy = -player.jumpForce;
    player.onGround = false;
  }
  keyJump = false;

  player.vy += GRAVITY*dt;
  if(player.vy > MAX_FALL_SPEED) player.vy = MAX_FALL_SPEED;

  player.x += player.vx*dt;
  resolveCollisions("x");

  player.y += player.vy*dt;
  player.onGround = false;
  resolveCollisions("y");

  const centerX = player.x + player.w/2;
  cameraX = centerX - canvas.width/2;
  if(cameraX < 0) cameraX = 0;
  const maxCam = cols*TILE_SIZE - canvas.width;
  if(cameraX > maxCam) cameraX = maxCam;

  handleCoins();

  // y bahut neeche gaya to life -1 + respawn
  if(player.y > canvas.height + 400){
    lives--;
    respawn();
  }

  document.getElementById("score").textContent = score;
  document.getElementById("lives").textContent = lives;
}

function resolveCollisions(axis){
  const future = {x:player.x,y:player.y,w:player.w,h:player.h};
  const startCol = Math.floor((player.x-5)/TILE_SIZE);
  const endCol   = Math.floor((player.x+player.w+5)/TILE_SIZE);
  const startRow = Math.floor((player.y-5)/TILE_SIZE);
  const endRow   = Math.floor((player.y+player.h+5)/TILE_SIZE);

  for(let r=startRow;r<=endRow;r++){
    for(let c=startCol;c<=endCol;c++){
      if(r<0||c<0||r>=rows||c>=cols) continue;
      const type = tiles[r][c];
      if(type===0 || type===3) continue;
      const tileRect = {x:c*TILE_SIZE,y:r*TILE_SIZE,w:TILE_SIZE,h:TILE_SIZE};
      if(rectIntersect(future,tileRect)){
        if(axis==="x"){
          if(player.vx>0) player.x = tileRect.x - player.w;
          else if(player.vx<0) player.x = tileRect.x + tileRect.w;
          player.vx = 0;
          future.x = player.x;
        }else{
          if(player.vy>0){
            player.y = tileRect.y - player.h;
            player.vy = 0;
            player.onGround = true;
          }else if(player.vy<0){
            player.y = tileRect.y + tileRect.h;
            player.vy = 0;
          }
          future.y = player.y;
        }
      }
    }
  }
}

function handleCoins(){
  const playerRect = {x:player.x,y:player.y,w:player.w,h:player.h};
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(tiles[r][c]===3){
        const coinRect = {x:c*TILE_SIZE+12,y:r*TILE_SIZE+12,w:24,h:24};
        if(rectIntersect(playerRect,coinRect)){
          tiles[r][c]=0;
          score += 10;
        }
      }
    }
  }
}

function respawn(){
  if(lives <= 0){
    // game reset
    lives = 3;
    score = 0;
  }
  player.x = TILE_SIZE*2;
  player.y = TILE_SIZE*8;
  player.vx = 0;
  player.vy = 0;
  cameraX = 0;
}

// ====== DRAW ======
function draw(){
  ctx.fillStyle = "#87CEEB";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // parallax hills
  ctx.fillStyle = "#7ec8e3";
  for(let i=-1;i<10;i++){
    const x = i*200 - (cameraX*0.3)%200;
    ctx.beginPath();
    ctx.moveTo(x,canvas.height-200);
    ctx.quadraticCurveTo(x+100,canvas.height-260,x+200,canvas.height-200);
    ctx.lineTo(x+200,canvas.height);
    ctx.lineTo(x,canvas.height);
    ctx.closePath();
    ctx.fill();
  }

  ctx.save();
  ctx.translate(-cameraX,0);

  // tiles
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const t = tiles[r][c];
      const x = c*TILE_SIZE;
      const y = r*TILE_SIZE;
      if(t===1 || t===2){
        ctx.fillStyle = t===1 ? "#8B4513" : "#a46b27";
        ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
        ctx.fillStyle = "#c08a3a";
        ctx.fillRect(x+6,y+6,TILE_SIZE-12,12);
      }else if(t===3){
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(x+TILE_SIZE/2,y+TILE_SIZE/2,14,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle="#FFA500";
        ctx.lineWidth=3;
        ctx.stroke();
      }
    }
  }

  // NINJA
  const px = player.x;
  const py = player.y;

  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.ellipse(px+player.w/2, py+player.h, 18, 6, 0, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = "#111111";
  ctx.fillRect(px, py, player.w, player.h-12);

  ctx.fillStyle = "#4444ff";
  ctx.fillRect(px, py+player.h-26, player.w, 6);

  ctx.fillStyle = "#111111";
  ctx.fillRect(px, py-14, player.w, 14);

  ctx.fillStyle = "#ff3333";
  ctx.fillRect(px, py-18, player.w, 4);
  ctx.fillRect(px+player.w-6, py-18, 8, 10);

  ctx.fillStyle = "#ffffff";
  ctx.fillRect(px+6, py-11, 4, 3);
  ctx.fillRect(px+player.w-10, py-11, 4, 3);

  ctx.fillStyle = "#000000";
  ctx.fillRect(px,            py+player.h-16, player.w/2, 16);
  ctx.fillRect(px+player.w/2, py+player.h-16, player.w/2, 16);

  ctx.restore();
}

loop();
</script>
</body>
</html>
