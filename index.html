<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mario Style Platformer</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{
  background:#222;
  overflow:hidden;
  font-family:Arial,Helvetica,sans-serif;
}
#gameCanvas{
  display:block;
  margin:0 auto;
  background:linear-gradient(to bottom,#87CEEB 0%,#98D8E8 50%,#E0F6FF 100%);
}
#ui{
  position:fixed;top:10px;left:10px;
  color:#fff;font-weight:bold;
  text-shadow:2px 2px 4px rgba(0,0,0,0.7);
}
</style>
</head>
<body>
<canvas id="gameCanvas" width="960" height="540"></canvas>
<div id="ui">Score: <span id="score">0</span> | Lives: <span id="lives">3</span></div>

<script>
// ====== BASIC SETUP ======
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const TILE_SIZE = 48;

// level: 0 empty, 1 ground, 2 platform, 3 coin, 4 enemy spawn
// (simple 1D array as rows of tiles) [web:95]
const level = [
  "000000000000000000000000000000000000000000",
  "000000000000000000000000000000000000000000",
  "000000000000000000000000000000000000000000",
  "000000000000000000000000000000000000000000",
  "000000000000003000000000000000000000000000",
  "000000000000001111000000000000000000000000",
  "000000000000000000000000003000000000000000",
  "000000000000000000000000001111000000000000",
  "000000000003000000000000000000000000000000",
  "000000000001111000000000000000000000000000",
  "000000000000000000000000000000000000000000",
  "111111111111111111111111111111111111111111",
];
// convert rows to 2D int array
const rows = level.length;
const cols = level[0].length;
const tiles = [];
for(let r=0;r<rows;r++){
  tiles[r] = [];
  for(let c=0;c<cols;c++){
    tiles[r][c] = parseInt(level[r][c],10);
  }
}

// ====== PLAYER & CAMERA ======
const player = {
  x: TILE_SIZE*2,
  y: TILE_SIZE*8,
  w: 32,
  h: 48,
  vx: 0,
  vy: 0,
  speed: 260,
  jumpForce: 700,
  onGround: false
};

let cameraX = 0;
let score = 0;
let lives = 3;

// enemies
const enemies = [];
for(let r=0;r<rows;r++){
  for(let c=0;c<cols;c++){
    if(tiles[r][c] === 4){
      enemies.push({
        x: c*TILE_SIZE,
        y: r*TILE_SIZE,
        w: 40,
        h: 40,
        vx: -60
      });
      tiles[r][c] = 0;
    }
  }
}

// ====== INPUT (PC + simple mobile) ======
let keyLeft=false,keyRight=false,keyJump=false;

window.addEventListener("keydown",e=>{
  if(["ArrowLeft","ArrowRight","ArrowUp","Space"," "].includes(e.code)) e.preventDefault();
  if(e.code==="ArrowLeft")  keyLeft=true;
  if(e.code==="ArrowRight") keyRight=true;
  if(e.code==="ArrowUp"||e.code==="Space") keyJump=true;
});
window.addEventListener("keyup",e=>{
  if(e.code==="ArrowLeft")  keyLeft=false;
  if(e.code==="ArrowRight") keyRight=false;
  if(e.code==="ArrowUp"||e.code==="Space") keyJump=false;
});

// tap to jump (mobile)
canvas.addEventListener("touchstart",e=>{
  e.preventDefault();
  keyJump = true;
});

// ====== PHYSICS HELPERS ======
const GRAVITY = 2000;
const MAX_FALL_SPEED = 1200;

function rectIntersect(a,b){
  return a.x < b.x + b.w &&
         a.x + a.w > b.x &&
         a.y < b.y + b.h &&
         a.y + a.h > b.y;
}

function getTileAt(x,y){
  if(x<0 || y<0) return 0;
  const c = Math.floor(x / TILE_SIZE);
  const r = Math.floor(y / TILE_SIZE);
  if(r<0 || r>=rows || c<0 || c>=cols) return 0;
  return tiles[r][c];
}

// ====== GAME LOOP ======
let lastTime = performance.now();
function loop(now=performance.now()){
  const dt = (now-lastTime)/1000;
  lastTime = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// ====== UPDATE ======
function update(dt){
  // horizontal input
  player.vx = 0;
  if(keyLeft)  player.vx -= player.speed;
  if(keyRight) player.vx += player.speed;

  // jump
  if(keyJump && player.onGround){
    player.vy = -player.jumpForce;
    player.onGround = false;
  }
  keyJump = false;

  // gravity
  player.vy += GRAVITY*dt;
  if(player.vy > MAX_FALL_SPEED) player.vy = MAX_FALL_SPEED;

  // move X with collision
  player.x += player.vx*dt;
  resolveCollisions("x");

  // move Y with collision
  player.y += player.vy*dt;
  player.onGround = false;
  resolveCollisions("y");

  // camera follow (center near player) [web:95]
  const centerX = player.x + player.w/2;
  cameraX = centerX - canvas.width/2;
  if(cameraX < 0) cameraX = 0;
  const maxCam = cols*TILE_SIZE - canvas.width;
  if(cameraX > maxCam) cameraX = maxCam;

  // enemies move
  enemies.forEach(e=>{
    e.x += e.vx*dt;
    // simple left/right patrol
    const leftTile  = getTileAt(e.x, e.y+e.h+1);
    const rightTile = getTileAt(e.x+e.w, e.y+e.h+1);
    if(!leftTile || !rightTile){
      e.vx *= -1;
    }
  });

  // player vs coin / enemy
  handleCoinsAndEnemies();

  // death if fall
  if(player.y > canvas.height + 200){
    respawn();
  }

  document.getElementById("score").textContent = score;
  document.getElementById("lives").textContent = lives;
}

function resolveCollisions(axis){
  const future = {
    x: player.x,
    y: player.y,
    w: player.w,
    h: player.h
  };

  const startCol = Math.floor((player.x-5)/TILE_SIZE);
  const endCol   = Math.floor((player.x+player.w+5)/TILE_SIZE);
  const startRow = Math.floor((player.y-5)/TILE_SIZE);
  const endRow   = Math.floor((player.y+player.h+5)/TILE_SIZE);

  for(let r=startRow;r<=endRow;r++){
    for(let c=startCol;c<=endCol;c++){
      if(r<0||c<0||r>=rows||c>=cols) continue;
      const type = tiles[r][c];
      if(type===0 || type===3) continue; // empty/coin
      const tileRect = {
        x:c*TILE_SIZE,
        y:r*TILE_SIZE,
        w:TILE_SIZE,
        h:TILE_SIZE
      };
      if(rectIntersect(future,tileRect)){
        if(axis==="x"){
          if(player.vx>0)   player.x = tileRect.x - player.w;
          else if(player.vx<0) player.x = tileRect.x + tileRect.w;
          player.vx = 0;
          future.x = player.x;
        }else{
          if(player.vy>0){
            player.y = tileRect.y - player.h;
            player.vy = 0;
            player.onGround = true;
          }else if(player.vy<0){
            player.y = tileRect.y + tileRect.h;
            player.vy = 0;
            // hit block from below -> TODO: bricks / ? block logic
          }
          future.y = player.y;
        }
      }
    }
  }
}

function handleCoinsAndEnemies(){
  // coins (type=3)
  const playerRect = {x:player.x,y:player.y,w:player.w,h:player.h};
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(tiles[r][c]===3){
        const coinRect = {x:c*TILE_SIZE+12,y:r*TILE_SIZE+12,w:24,h:24};
        if(rectIntersect(playerRect,coinRect)){
          tiles[r][c]=0;
          score += 10;
        }
      }
    }
  }

  // enemies
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    const er = {x:e.x,y:e.y,w:e.w,h:e.h};
    if(rectIntersect(playerRect,er)){
      // if player is falling down and above enemy -> stomp
      if(player.vy > 0 && player.y + player.h - 10 < e.y){
        enemies.splice(i,1);
        score += 50;
        player.vy = -player.jumpForce*0.6; // bounce
      }else{
        // hit from side -> lose life
        lives--;
        respawn();
        break;
      }
    }
  }
}

function respawn(){
  player.x = TILE_SIZE*2;
  player.y = TILE_SIZE*8;
  player.vx = 0;
  player.vy = 0;
  cameraX = 0;
  if(lives<=0){
    lives = 3;
    score = 0;
  }
}

// ====== DRAW ======
function draw(){
  // sky
  ctx.fillStyle = "#87CEEB";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // parallax hills [web:93]
  ctx.fillStyle = "#7ec8e3";
  for(let i=-1;i<10;i++){
    const x = i*200 - (cameraX*0.3)%200;
    ctx.beginPath();
    ctx.moveTo(x,canvas.height-200);
    ctx.quadraticCurveTo(x+100,canvas.height-260,x+200,canvas.height-200);
    ctx.lineTo(x+200,canvas.height);
    ctx.lineTo(x,canvas.height);
    ctx.closePath();
    ctx.fill();
  }

  ctx.save();
  ctx.translate(-cameraX,0);

  // tiles
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const t = tiles[r][c];
      const x = c*TILE_SIZE;
      const y = r*TILE_SIZE;
      if(t===1 || t===2){
        ctx.fillStyle = t===1 ? "#8B4513" : "#a46b27";
        ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
        ctx.fillStyle = "#c08a3a";
        ctx.fillRect(x+6,y+6,TILE_SIZE-12,12); // top highlight
      }else if(t===3){
        // coin
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(x+TILE_SIZE/2,y+TILE_SIZE/2,14,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle="#FFA500";
        ctx.lineWidth=3;
        ctx.stroke();
      }
    }
  }

  // enemies
  enemies.forEach(e=>{
    ctx.fillStyle="#222";
    ctx.fillRect(e.x,e.y,e.w,e.h);
    ctx.fillStyle="#ff5555";
    ctx.fillRect(e.x+6,e.y+6,e.w-12,12);
  });

  // player (simple mario-like)
  ctx.fillStyle="#ffcc99";
  ctx.fillRect(player.x,player.y-12,player.w,12); // head
  ctx.fillStyle="#0066ff";
  ctx.fillRect(player.x,player.y,player.w,player.h-16); // body
  ctx.fillStyle="#000";
  ctx.fillRect(player.x,player.y+player.h-16,player.w/2,16);
  ctx.fillRect(player.x+player.w/2,player.y+player.h-16,player.w/2,16);

  ctx.restore();
}

loop();
</script>
</body>
</html>
